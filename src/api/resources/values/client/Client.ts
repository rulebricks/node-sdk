/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Rulebricks from "../../../index";
import urlJoin from "url-join";
import * as serializers from "../../../../serialization/index";
import * as errors from "../../../../errors/index";

export declare namespace Values {
    export interface Options {
        environment?: core.Supplier<environments.RulebricksEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey: core.Supplier<string>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

/**
 * Operations for managing dynamic values referenced in rules
 */
export class Values {
    constructor(protected readonly _options: Values.Options) {}

    /**
     * Retrieve all dynamic values for the authenticated user. Use the 'include' parameter to control whether usage information is returned.
     *
     * @param {Rulebricks.ValuesListRequest} request
     * @param {Values.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Rulebricks.NotFoundError}
     * @throws {@link Rulebricks.InternalServerError}
     *
     * @example
     *     await client.values.list({
     *         include: "usage"
     *     })
     */
    public async list(
        request: Rulebricks.ValuesListRequest = {},
        requestOptions?: Values.RequestOptions,
    ): Promise<Rulebricks.DynamicValueListResponse> {
        const { name, include } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (name != null) {
            _queryParams["name"] = name;
        }

        if (include != null) {
            _queryParams["include"] = include;
        }

        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.RulebricksEnvironment.Default,
                "values",
            ),
            method: "GET",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.DynamicValueListResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Rulebricks.NotFoundError(_response.error.body);
                case 500:
                    throw new Rulebricks.InternalServerError(_response.error.body);
                default:
                    throw new errors.RulebricksError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.RulebricksError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.RulebricksTimeoutError("Timeout exceeded when calling GET /values.");
            case "unknown":
                throw new errors.RulebricksError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Update existing dynamic values or add new ones for the authenticated user. Supports both flat and nested object structures. Nested objects are automatically flattened using dot notation and keys are converted to readable format (e.g., 'user_name' becomes 'User Name', nested 'user.contact_info.email' becomes 'User.Contact Info.Email').
     *
     * @param {Rulebricks.UpdateValuesRequest} request
     * @param {Values.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Rulebricks.BadRequestError}
     * @throws {@link Rulebricks.ForbiddenError}
     * @throws {@link Rulebricks.InternalServerError}
     *
     * @example
     *     await client.values.update({
     *         values: {
     *             "Favorite Color": "blue",
     *             "Age": 30,
     *             "Is Student": false,
     *             "Hobbies": [
     *                 "reading",
     *                 "cycling"
     *             ]
     *         },
     *         accessGroups: ["marketing", "developers"]
     *     })
     *
     * @example
     *     await client.values.update({
     *         values: {
     *             "user_profile": {
     *                 "first_name": "Alice",
     *                 "last_name": "Johnson",
     *                 "contact_info": {
     *                     "email_address": "alice@example.com",
     *                     "phone_number": "555-0123"
     *                 }
     *             },
     *             "account_settings": {
     *                 "is_premium_user": true,
     *                 "subscription_tier": "gold",
     *                 "preferences": [
     *                     "email_notifications",
     *                     "sms_alerts"
     *                 ]
     *             },
     *             "account_balance": 1250.75
     *         },
     *         accessGroups: ["marketing", "developers"]
     *     })
     *
     * @example
     *     await client.values.update({
     *         values: {
     *             "Company Name": "Acme Corp",
     *             "company_details": {
     *                 "founded_year": 2020,
     *                 "employee_count": 150,
     *                 "headquarters": {
     *                     "city": "San Francisco",
     *                     "state": "CA",
     *                     "country": "USA"
     *                 }
     *             },
     *             "Is Public": false,
     *             "tags": [
     *                 "tech",
     *                 "startup",
     *                 "saas"
     *             ]
     *         },
     *         accessGroups: ["marketing"]
     *     })
     */
    public async update(
        request: Rulebricks.UpdateValuesRequest,
        requestOptions?: Values.RequestOptions,
    ): Promise<Rulebricks.DynamicValueListResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.RulebricksEnvironment.Default,
                "values",
            ),
            method: "POST",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            requestType: "json",
            body: serializers.UpdateValuesRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.DynamicValueListResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Rulebricks.BadRequestError(_response.error.body);
                case 403:
                    throw new Rulebricks.ForbiddenError(_response.error.body);
                case 500:
                    throw new Rulebricks.InternalServerError(_response.error.body);
                default:
                    throw new errors.RulebricksError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.RulebricksError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.RulebricksTimeoutError("Timeout exceeded when calling POST /values.");
            case "unknown":
                throw new errors.RulebricksError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Delete a specific dynamic value for the authenticated user by its ID.
     *
     * @param {Rulebricks.ValuesDeleteRequest} request
     * @param {Values.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Rulebricks.BadRequestError}
     * @throws {@link Rulebricks.NotFoundError}
     * @throws {@link Rulebricks.InternalServerError}
     *
     * @example
     *     await client.values.delete({
     *         id: "id"
     *     })
     */
    public async delete(
        request: Rulebricks.ValuesDeleteRequest,
        requestOptions?: Values.RequestOptions,
    ): Promise<Rulebricks.SuccessMessage> {
        const { id } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["id"] = id;
        const _response = await core.fetcher({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.RulebricksEnvironment.Default,
                "values",
            ),
            method: "DELETE",
            headers: {
                "X-Fern-Language": "JavaScript",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
                ...requestOptions?.headers,
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.SuccessMessage.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Rulebricks.BadRequestError(_response.error.body);
                case 404:
                    throw new Rulebricks.NotFoundError(_response.error.body);
                case 500:
                    throw new Rulebricks.InternalServerError(_response.error.body);
                default:
                    throw new errors.RulebricksError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.RulebricksError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.RulebricksTimeoutError("Timeout exceeded when calling DELETE /values.");
            case "unknown":
                throw new errors.RulebricksError({
                    message: _response.error.errorMessage,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "x-api-key": apiKeyValue };
    }
}
