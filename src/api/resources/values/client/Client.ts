// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as Rulebricks from "../../../index.js";

export declare namespace ValuesClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

/**
 * Operations for managing dynamic values referenced in rules
 */
export class ValuesClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ValuesClient.Options>;

    constructor(options: ValuesClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Retrieve all dynamic values for the authenticated user. Use the 'include' parameter to control whether usage information is returned.
     *
     * @param {Rulebricks.ListValuesRequest} request
     * @param {ValuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Rulebricks.NotFoundError}
     * @throws {@link Rulebricks.InternalServerError}
     *
     * @example
     *     await client.values.list({
     *         include: "usage"
     *     })
     */
    public list(
        request: Rulebricks.ListValuesRequest = {},
        requestOptions?: ValuesClient.RequestOptions,
    ): core.HttpResponsePromise<Rulebricks.DynamicValueListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: Rulebricks.ListValuesRequest = {},
        requestOptions?: ValuesClient.RequestOptions,
    ): Promise<core.WithRawResponse<Rulebricks.DynamicValueListResponse>> {
        const { name, include } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (name != null) {
            _queryParams.name = name;
        }

        if (include != null) {
            _queryParams.include = include;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.RulebricksEnvironment.Default,
                "values",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Rulebricks.DynamicValueListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new Rulebricks.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Rulebricks.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.RulebricksError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/values");
    }

    /**
     * Update existing dynamic values or add new ones for the authenticated user. Supports both flat and nested object structures. Nested objects are automatically flattened using dot notation and keys are converted to readable format (e.g., 'user_name' becomes 'User Name', nested 'user.contact_info.email' becomes 'User.Contact Info.Email').
     *
     * @param {Rulebricks.UpdateValuesRequest} request
     * @param {ValuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Rulebricks.BadRequestError}
     * @throws {@link Rulebricks.ForbiddenError}
     * @throws {@link Rulebricks.InternalServerError}
     *
     * @example
     *     await client.values.update({
     *         values: {
     *             "Favorite Color": "blue",
     *             "Age": 30,
     *             "Is Student": false,
     *             "Hobbies": [
     *                 "reading",
     *                 "cycling"
     *             ]
     *         },
     *         user_groups: ["marketing", "developers"]
     *     })
     *
     * @example
     *     await client.values.update({
     *         values: {
     *             "user_profile": {
     *                 "first_name": "Alice",
     *                 "last_name": "Johnson",
     *                 "contact_info": {
     *                     "email_address": "alice@example.com",
     *                     "phone_number": "555-0123"
     *                 }
     *             },
     *             "account_settings": {
     *                 "is_premium_user": true,
     *                 "subscription_tier": "gold",
     *                 "preferences": [
     *                     "email_notifications",
     *                     "sms_alerts"
     *                 ]
     *             },
     *             "account_balance": 1250.75
     *         },
     *         user_groups: ["marketing", "developers"]
     *     })
     *
     * @example
     *     await client.values.update({
     *         values: {
     *             "Company Name": "Acme Corp",
     *             "company_details": {
     *                 "founded_year": 2020,
     *                 "employee_count": 150,
     *                 "headquarters": {
     *                     "city": "San Francisco",
     *                     "state": "CA",
     *                     "country": "USA"
     *                 }
     *             },
     *             "Is Public": false,
     *             "tags": [
     *                 "tech",
     *                 "startup",
     *                 "saas"
     *             ]
     *         },
     *         user_groups: ["marketing"]
     *     })
     */
    public update(
        request: Rulebricks.UpdateValuesRequest,
        requestOptions?: ValuesClient.RequestOptions,
    ): core.HttpResponsePromise<Rulebricks.DynamicValueListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
    }

    private async __update(
        request: Rulebricks.UpdateValuesRequest,
        requestOptions?: ValuesClient.RequestOptions,
    ): Promise<core.WithRawResponse<Rulebricks.DynamicValueListResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.RulebricksEnvironment.Default,
                "values",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Rulebricks.DynamicValueListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Rulebricks.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new Rulebricks.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Rulebricks.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.RulebricksError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/values");
    }

    /**
     * Delete a specific dynamic value for the authenticated user by its ID.
     *
     * @param {Rulebricks.DeleteValuesRequest} request
     * @param {ValuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Rulebricks.BadRequestError}
     * @throws {@link Rulebricks.NotFoundError}
     * @throws {@link Rulebricks.InternalServerError}
     *
     * @example
     *     await client.values.delete({
     *         id: "id"
     *     })
     */
    public delete(
        request: Rulebricks.DeleteValuesRequest,
        requestOptions?: ValuesClient.RequestOptions,
    ): core.HttpResponsePromise<Rulebricks.SuccessMessage> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Rulebricks.DeleteValuesRequest,
        requestOptions?: ValuesClient.RequestOptions,
    ): Promise<core.WithRawResponse<Rulebricks.SuccessMessage>> {
        const { id } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.id = id;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.RulebricksEnvironment.Default,
                "values",
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Rulebricks.SuccessMessage, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Rulebricks.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new Rulebricks.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Rulebricks.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.RulebricksError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/values");
    }
}
