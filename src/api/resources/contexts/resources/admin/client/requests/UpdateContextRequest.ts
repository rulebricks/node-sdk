// This file was auto-generated by Fern from our API Definition.

/**
 * @example
 *     {
 *         id: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
 *         name: "Updated Customer",
 *         description: "Updated description for premium customers"
 *     }
 */
export interface UpdateContextRequest {
    /** The unique identifier for the context. */
    id: string;
    /** The name of the context. */
    name?: string;
    /** The slug of the context. */
    slug?: string;
    /** The description of the context. */
    description?: string;
    /** Updated schema fields for the context. */
    schema?: UpdateContextRequest.Schema.Item[];
    /** When true, bound rules and flows automatically execute when their inputs are satisfied. */
    auto_execute_decisions?: boolean;
    /** Time-to-live in seconds for live context instances. Instances expire after this duration. */
    ttl_seconds?: number | null;
    /** Maximum number of history entries to retain per field. */
    history_limit?: number;
    /** How to handle fields that don't match the schema. */
    on_schema_mismatch?: UpdateContextRequest.OnSchemaMismatch;
    /** Webhook URL called when a rule or flow successfully solves. */
    webhook_on_solve?: string | null;
    /** Webhook URL called when a live context expires due to TTL. */
    webhook_on_expire?: string | null;
}

export namespace UpdateContextRequest {
    export type Schema = Schema.Item[];

    export namespace Schema {
        export interface Item {
            key?: string;
            name?: string;
            type?: string;
            defaultValue?: unknown;
        }
    }

    /** How to handle fields that don't match the schema. */
    export const OnSchemaMismatch = {
        Ignore: "ignore",
        Reject: "reject",
    } as const;
    export type OnSchemaMismatch = (typeof OnSchemaMismatch)[keyof typeof OnSchemaMismatch];
}
